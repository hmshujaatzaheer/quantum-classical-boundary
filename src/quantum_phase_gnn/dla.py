"""
Dynamical Lie Algebra (DLA) Computation
=======================================

Implementation of Algorithm 1: DLA-COMPUTE from the PhD proposal
"Characterizing Quantum-Classical Computational Boundaries"

THEORETICAL BACKGROUND:
======================
The Dynamical Lie Algebra captures the algebraic structure generated by
a quantum circuit's parameterized gates. Ragone et al. (2024) proved:

    Var[∂C/∂θ] ∝ dim(DLA) / 4^n

This connects trainability to algebraic structure:
- Small DLA → Trainable (no barren plateau)
- Large DLA (≈ 4^n) → Barren plateau

Author: PhD Research - ETH Zurich Quantum Computing Group
References:
- Ragone et al. (2024) "A Lie algebraic theory of barren plateaus"
- Larocca et al. (2022) "Diagnosing barren plateaus with tools from quantum optimal control"
"""

import numpy as np
from typing import List, Tuple, Optional, Set
from functools import reduce

# Pauli matrices
I = np.array([[1, 0], [0, 1]], dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)


def commutator(A: np.ndarray, B: np.ndarray) -> np.ndarray:
    """Compute matrix commutator [A, B] = AB - BA"""
    return A @ B - B @ A


# ============================================================================
# ALGORITHM 1: DLA-COMPUTE (Lines 42-98)
# ============================================================================

class DLAComputer:
    """
    Compute Dynamical Lie Algebra dimension for quantum circuits.
    
    ALGORITHM 1: DLA-COMPUTE
    ========================
    Input: Set of generators G = {G₁, G₂, ..., Gₘ}
    Output: dim(DLA)
    
    Procedure:
    1. Initialize basis B = G
    2. Repeat until convergence:
       a. For each pair (Gᵢ, Gⱼ) in B:
          - Compute [Gᵢ, Gⱼ]
          - If linearly independent from B, add to B
    3. Return |B|
    
    Complexity: O(d⁵) where d = dim(DLA)
    """
    
    def __init__(self, n_qubits: int, tolerance: float = 1e-10):
        """
        Initialize DLA computer.
        
        Parameters
        ----------
        n_qubits : int
            Number of qubits in the system
        tolerance : float
            Numerical tolerance for linear independence checks
        """
        self.n_qubits = n_qubits
        self.dim = 2 ** n_qubits
        self.tolerance = tolerance
    
    def compute_dimension(self, generators: List[np.ndarray],
                          max_iterations: int = 100,
                          verbose: bool = False) -> int:
        """
        Compute DLA dimension from generators.
        
        Parameters
        ----------
        generators : List[np.ndarray]
            Initial Hermitian generators (from parameterized gates)
        max_iterations : int
            Maximum iterations for convergence
        verbose : bool
            Print progress information
            
        Returns
        -------
        int
            Dimension of the Dynamical Lie Algebra
        """
        # Step 1: Initialize basis with generators
        basis = [g.copy() for g in generators if not self._is_zero(g)]
        
        # Step 2: Iterate until convergence
        for iteration in range(max_iterations):
            new_elements = []
            for i in range(len(basis)):
                for j in range(i + 1, len(basis)):
                    comm = commutator(basis[i], basis[j])
                    if not self._is_zero(comm):
                        if self._is_linearly_independent(comm, basis + new_elements):
                            new_elements.append(comm)
            if len(new_elements) == 0:
                break
            basis.extend(new_elements)
        
        # Step 3: Return dimension
        return len(basis)
    
    # End of Algorithm 1 core (line 98)
    # ========================================================================
    
    def compute_dla_ratio(self, generators: List[np.ndarray]) -> float:
        """
        Compute normalized DLA ratio: r_DLA = dim(DLA) / (4^n - 1)
        
        This is a key feature for QUANTUM-PHASE-GNN:
        - r_DLA ≈ 0: Restricted algebra → Trainable
        - r_DLA ≈ 1: Full algebra → Barren plateau
        """
        dim = self.compute_dimension(generators)
        max_dim = 4 ** self.n_qubits - 1
        return dim / max_dim
    
    def embed_generator(self, G_single: np.ndarray, qubit: int) -> np.ndarray:
        """Embed single-qubit generator into n-qubit Hilbert space."""
        ops = [I] * self.n_qubits
        ops[qubit] = G_single
        return reduce(np.kron, ops)
    
    def get_two_qubit_generator(self, G1: np.ndarray, G2: np.ndarray,
                                 qubit1: int, qubit2: int) -> np.ndarray:
        """Create two-qubit generator for entangling gates."""
        ops = [I] * self.n_qubits
        ops[qubit1] = G1
        ops[qubit2] = G2
        return reduce(np.kron, ops)
    
    def _is_zero(self, matrix: np.ndarray) -> bool:
        """Check if matrix is numerically zero."""
        return np.allclose(matrix, 0, atol=self.tolerance)
    
    def _is_linearly_independent(self, new_matrix: np.ndarray,
                                  basis: List[np.ndarray]) -> bool:
        """Check linear independence using Gram-Schmidt orthogonalization."""
        if len(basis) == 0:
            return True
        new_vec = new_matrix.flatten()
        residual = new_vec.copy()
        for b in basis:
            b_vec = b.flatten()
            proj = np.vdot(b_vec, residual) / np.vdot(b_vec, b_vec)
            residual = residual - proj * b_vec
        return np.linalg.norm(residual) > self.tolerance


def extract_circuit_generators(circuit_gates: List[dict], n_qubits: int) -> List[np.ndarray]:
    """Extract Hermitian generators from circuit description."""
    dla = DLAComputer(n_qubits)
    generators = []
    for gate_info in circuit_gates:
        gate = gate_info['gate']
        qubits = gate_info['qubits']
        if gate in ['Rx', 'X_rot']:
            generators.append(dla.embed_generator(X, qubits[0]))
        elif gate in ['Ry', 'Y_rot']:
            generators.append(dla.embed_generator(Y, qubits[0]))
        elif gate in ['Rz', 'Z_rot']:
            generators.append(dla.embed_generator(Z, qubits[0]))
        elif gate in ['CNOT', 'CX']:
            proj_1 = (I - Z) / 2
            generators.append(dla.get_two_qubit_generator(proj_1, X, qubits[0], qubits[1]))
        elif gate == 'CZ':
            proj_1 = (I - Z) / 2
            generators.append(dla.get_two_qubit_generator(proj_1, Z, qubits[0], qubits[1]))
    return generators


if __name__ == "__main__":
    print("DLA Computation Module - Algorithm 1 Implementation")
    dla = DLAComputer(n_qubits=2)
    circuit = [
        {'gate': 'Ry', 'qubits': [0]},
        {'gate': 'Ry', 'qubits': [1]},
        {'gate': 'CNOT', 'qubits': [0, 1]},
    ]
    generators = extract_circuit_generators(circuit, n_qubits=2)
    dim = dla.compute_dimension(generators)
    print(f"DLA dimension: {dim}")
    print(f"DLA ratio: {dla.compute_dla_ratio(generators):.4f}")
